<!DOCTYPE html>
<html lang="en">
	<head>
		<title></title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				color: #ffffff;
				padding: 5px;
				font-family:Monospace;
				font-size:13px;
				font-weight: bold;
				text-align:center;
			}

			a {
				color: #ffffff;
			}


            #pano_container {
                position:absolute;
                left:8px;
                top:348px;
                width:832px;
                height:416px;
                z-index:20;
                display:block;
                pointer-events:none;
                border:2px black solid;
            }
            #depth_container {
                position:absolute;
                left:8px;
                top:80px;
                width:512px;
                height:256px;
                z-index:10;
                display:block;
                pointer-events:none;
                border:2px black solid;
            }
            .hide {
                opacity:0;
                transition:opacity .5s ease-out;
            }
            .show {
                opacity:1;
                transition:opacity .5s ease-out;
            }

		</style>
	</head>
	<body>

		<div id="container"></div>
        <div id="pano_container" class="hide"></div>
        <div id="depth_container" class="show"></div>
		<div id="info">
			<a href="http://threejs.org" target="_blank">three.js webgl</a> - equirectangular panorama demo
		</div>
        <div id="container"></div>

        <script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?v=3.exp"></script>
		<script src="https://unpkg.com/three@0.81.1/build/three.min.js"></script>
        <script src="https://unpkg.com/three-text2d@0.2.3-rc1/dist/three-text2d.js"></script>
        

        <script type="text/javascript" src="lib/dat.gui.min.js"></script>
        <script type="text/javascript" src="lib/jquery.min.js"></script>
        <script type="text/javascript" src="lib/jquery.base64.min.js"></script>
        <script type="text/javascript" src="lib/zpipe.min.js"></script>
        <script type="text/javascript" src="lib/png.js"></script>
        <script type="text/javascript" src="lib/GSVPano.js"></script>
        <script type="text/javascript" src="lib/GSVPanoDepth.js"></script>

		<script>
            var raycaster = new THREE.Raycaster(); 
            var mouse = new THREE.Vector2();
            var pano_map
            var depth_img, loaded;
            var relative_positions;
            var mesh, mesh_click;
            var textureLoader = new THREE.TextureLoader();
            var point_parameter = [
					[ 0xffffff, textureLoader.load( "sprites/marker_1.png" ), 10 ],
				];
            var point1_texture = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAAPCAYAAAA71pVKAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAlwSFlzAAAOwwAADsMBx2+oZAAAABp0RVh0U29mdHdhcmUAUGFpbnQuTkVUIHYzLjUuMTFH80I3AAAAW0lEQVQ4T+2SwQoAIAhD9f8/eplkSUzvQYGX2tK9UgBCl+o5AJRqppmW2HZUoeHGKX7UHKNXTJxIznYDMsQbJtFxs3sWtBteuqTvnEemnZtMHqnN/D8Jf9eCywBg2TnnAAWR+wAAAABJRU5ErkJggg=='
            var req_pano_id = gup('panoid');
            var req_lon = gup('lon');
            var req_lat = gup('lat');
            var gsv = new google.maps.StreetViewService();
            var pid;
            
            var measures = [];
            
			var camera, scene, renderer;

			var isUserInteracting = false,
			onMouseDownMouseX = 0, onMouseDownMouseY = 0,
			lon = 0, onMouseDownLon = 0,
			lat = 0, onMouseDownLat = 0,
			phi = 0, theta = 0;

			init();
			animate();


            function png2depth_map(url){
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.responseType = 'arraybuffer';
                
                xhr.onload = function(e){
                    if (this.status == 200){
                        var reader = new PNGReader(this.response);
                        reader.parse(function(err, png){
                            if (err) throw err;
                            depth_img = png
                            console.log('depth_map loaded');
                            console.log(depth_map.getPixel(100,100));
                        });
                    }
                };

                xhr.send();
            }

            function convertCanvasToImage(canvas) {
                var image = new Image();
                image.src = canvas.toDataURL("image/png");
                return image;
            }

            function toDataUrl(url, callback) {
              var xhr = new XMLHttpRequest();
              xhr.responseType = 'blob';
              xhr.onload = function() {
                var reader = new FileReader();
                reader.onloadend = function() {
                  callback(reader.result);
                }
                reader.readAsDataURL(xhr.response);
              };
              xhr.open('GET', url);
              xhr.send();
            }

            function gup(name)
            {
              name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
              var regexS = "[\\?&]"+name+"=([^&#]*)";
              var regex = new RegExp( regexS );
              var results = regex.exec( window.location.href );
              if( results == null )
                return "";
              else
                return results[1];
            }

			function init() {
                
                //var lat = 45.4077732232;
                //var lon = 11.8729286882;
                //var pano_id = 'hzIQEgRPsbSm0T8q0NUi9Q';
                
                
                console.log (req_pano_id,parseFloat(req_lat), parseFloat(req_lon));

                if (req_pano_id != "") {
                    build_pano(req_pano_id);
                } else {
                    if ((req_lat != "") && (req_lon != "")) {
                        var latLng = new google.maps.LatLng(parseFloat(req_lat), parseFloat(req_lon)); //{lat: parseFloat(req_lat), lng: parseFloat(req_lon)}
                        gsv.getPanoramaByLocation( latLng, 50, 
                            function (data, status) {
                                if (status === google.maps.StreetViewStatus.OK) {
                                    build_pano(data.location.pano);
                                } else {
                                    console.error("Unable to get location");
                                };
                        })
                    } else {
                        build_pano('hzIQEgRPsbSm0T8q0NUi9Q');
                    }
                }
            }

            function build_pano( pano_id ) {

                //toDataUrl("http://172.25.193.167/jpann/point2.png", function(base64Img) {console.log(base64Img);});

                document.getElementById('info').innerHTML = "PANOID: "+pano_id

                var pano_loader = new GSVPANO.PanoLoader({
                    zoom: 2
                });
                var depth_loader = new GSVPANO.PanoDepthLoader();
                

                gsv.getPanoramaById(pano_id,
                    function (data, status) {
                        if (status === google.maps.StreetViewStatus.OK) {
                            pano_loader.load(new google.maps.LatLng(data.location.latLng.lat(), data.location.latLng.lng()));
                        } else {
                            console.error("Unable to get starting pano ID ");
                        }
                    });

                //pano_loader.load(new google.maps.LatLng(lat, lon));
                

                pano_loader.onError = function(message){
                    console.log('PanoLoaderError:' + message)
                };


                pano_loader.onPanoramaLoad = function () {
                    console.log("pano_loaded_start");
                    var pano_container = document.getElementById('pano_container');
                    while (pano_container.firstChild) {
                        pano_container.removeChild(pano_container.firstChild);
                    }
                    pano_container.appendChild(this.canvas);

    				var container;
    				container = document.getElementById( 'container' );
    
    				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1100 );
    				camera.target = new THREE.Vector3( 0, 0, 0 );
    
    				scene = new THREE.Scene();
    
    				var geometry = new THREE.SphereGeometry( 500, 120, 80 );
    				geometry.scale( 1, 1, 1 );
                    
                    var pano_texture = new THREE.Texture(this.canvas);

    				var material = new THREE.MeshBasicMaterial( {
    					//map: new THREE.TextureLoader().load( 'test.png' ),
                        map: pano_texture,
                        side: THREE.DoubleSide
    				} );
                    
                    pano_texture.needsUpdate = true;
    
                    mesh = new THREE.Mesh( geometry, material );
    				scene.add( mesh );
    
    				renderer = new THREE.WebGLRenderer();
    				renderer.setPixelRatio( window.devicePixelRatio );
    				renderer.setSize( window.innerWidth, window.innerHeight );
    				container.appendChild( renderer.domElement );
    
    				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
    				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
    				document.addEventListener( 'mouseup', onDocumentMouseUp, false );
    				document.addEventListener( 'wheel', onDocumentMouseWheel, false );
                    document.addEventListener( 'dblclick', onDocumentDblclick, false );
                    window.addEventListener( 'resize', onWindowResize, false );
                    console.log("pano_loaded_end");
                    console.log(this.panoId);
                    depth_loader.load(this.panoId);

                }

				//

                depth_loader.onDepthLoad = function () {
                    console.log("depth_loaded_start");
                    var canvas = document.createElement("canvas");
                    var context = canvas.getContext('2d');
                    canvas.setAttribute('width', this.depthMap.width);
                    canvas.setAttribute('height', this.depthMap.height);
                    var image = context.getImageData(0, 0, this.depthMap.width, this.depthMap.height);
                    for (var y = 0; y < this.depthMap.height; ++y) {
                        for (var x = this.depthMap.width; x > 0 ; --x) {
                            var col = this.depthMap.depthMap[y * this.depthMap.width + x] / 50 * 255;
                            image.data[4 * (y * this.depthMap.width + x) + 0] = col;
                            image.data[4 * (y * this.depthMap.width + x) + 1] = col;
                            image.data[4 * (y * this.depthMap.width + x) + 2] = col;
                            image.data[4 * (y * this.depthMap.width + x) + 3] = 255;
                        }
                    }
                    context.putImageData(image, 0, 0);
                    var depth_container = document.getElementById('depth_container');
                    while (depth_container.firstChild) {
                        depth_container.removeChild(depth_container.firstChild);
                    }

                    depth_container.appendChild(canvas);

                    var geometry_click = new THREE.SphereGeometry( 400, 120, 80 );
                    geometry_click.scale( 1, 1, 1 );
                    
                    var depth_texture = new THREE.Texture(canvas);
    
                    var material_click = new THREE.MeshBasicMaterial( {
                        //map: new THREE.TextureLoader().load( 'null.png' ),
                        map: depth_texture,
                        //color: 0x00ffff, 
                        wireframe: true, 
                        side: THREE.DoubleSide,
                        wireframeLinewidth: 3.0,
                        visible: true
                    } );
                    
                    depth_texture.needsUpdate = true;
                    mesh_click = new THREE.Mesh( geometry_click, material_click );
                    scene.add( mesh_click );

                    /*
                    var reader = new PNGReader(convertCanvasToImage(depth_container.firstChild));
                    reader.parse(function(err, png){
                        if (err) throw err;
                        depth_img = png;
                        console.log('depth_img loaded');
                        console.log(depth_map.getPixel(100,100));
                    });
                    */
                    depth_img = context;

                    //Relative position calculation
                    relative_positions = [];
                    var n = 0;
                    for (var y = 0; y < this.depthMap.height; ++y) {
                        var lat = (y / this.depthMap.height) * 180.0 - 90.0;
                        var r = Math.cos(lat * Math.PI / 180.0);
                        var row_positions = [];
                        for (var x = this.depthMap.width; x > 0 ; --x) {
                            var depth = parseFloat(this.depthMap.depthMap[y * this.depthMap.width + (this.depthMap.width - x)]);
                            var lng = (1-(x / this.depthMap.width)) * 360.0 - 180.0;
                            var pos = new THREE.Vector3();
                            pos.x = (r * Math.cos(lng * Math.PI / 180.0));
                            pos.y = (Math.sin(lat * Math.PI / 180.0));
                            pos.z = (r * Math.sin(lng * Math.PI / 180.0));
                            pos.d = depth;
                            pos.multiplyScalar(depth);
                            pos.multiplyScalar(2.0);
                            row_positions.push(pos);
                            n++;
                        }
                        relative_positions.push(row_positions);
                    }

                    console.log("depth_loaded_end");

				}

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseDown( event ) {

				event.preventDefault();

				isUserInteracting = true;

				onPointerDownPointerX = event.clientX;
				onPointerDownPointerY = event.clientY;

				onPointerDownLon = lon;
				onPointerDownLat = lat;

			}

			function onDocumentDblclick( event ) {

				//lon = ( onPointerDownPointerX - event.clientX ) * 0.1 + onPointerDownLon;
                //lat = ( event.clientY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;
                console.log([event.clientX,event.clientY,lon,lat,]);
                console.log(depth_img);
                
                mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
                raycaster.setFromCamera( mouse, camera );
                var intersect = raycaster.intersectObject( mesh_click );
                console.log(intersect[0].point);
                console.log(intersect[0].uv);
                var geometry = new THREE.Geometry()
                geometry.vertices.push( new THREE.Vector3(intersect[0].point.x,intersect[0].point.y,intersect[0].point.z));
				var material = new THREE.PointsMaterial( { 
                    size: 15, 
                    map: new THREE.TextureLoader().load( point1_texture ), 
                    sizeAttenuation: false, 
                    transparent : true } );
                material.color.setHSL( 1.0, 1.0, 1.0 );
                var puntatore = new THREE.Points( geometry, material );
                scene.add( puntatore );
                var map_y = Math.round(256-256*intersect[0].uv.y);
                var map_x = Math.round(512*intersect[0].uv.x);
                
                var SpriteText2D = THREE_Text.SpriteText2D;
                var textAlign = THREE_Text.textAlign;
                console.log(depth_img.getImageData(map_x, map_y, 1, 1).data);
                //var depth_txt = depth_map[map_y][map_x]; depth.toString()
                console.log(relative_positions[map_y][map_x]);
                var depth_txt = depth_img.getImageData(map_x, map_y, 1, 1).data.toString();
                var depth_txt = relative_positions[map_y][map_x].d.toFixed(2).toString();
                var text2 = new SpriteText2D(depth_txt, {align: textAlign.right, font: '12px Arial', fillStyle: '#ff0000' });
                text2.position.set(intersect[0].point.x,intersect[0].point.y,intersect[0].point.z);
                scene.add(text2)
                measures.push({true_point:relative_positions[map_y][map_x],view_point:intersect[0].point});
                console.log(measures.length);
                
                if (measures.length == 2) {
                    console.log(measures);
                    var measure_line = new THREE.Line3( measures[0].true_point, measures[1].true_point );
                    var view_line = new THREE.Line3( measures[0].view_point, measures[1].view_point );
                    var measure_text = new SpriteText2D((measure_line.distance()*6/9.73).toFixed(2), {align: textAlign.right, font: '16px Arial bold', fillStyle: '#00ff00' });
                    measure_text.position.set (view_line.center().x,view_line.center().y,view_line.center().z);
                    scene.add(measure_text);
                    var measure_geom = new THREE.Geometry ();
                    measure_geom.vertices.push(measures[0].view_point, measures[1].view_point);
                    scene.add( new THREE.Line( measure_geom, new THREE.LineBasicMaterial({color: 0x00ff00, linewidth:3})) );
                    measures = [];
                }

			}

			function onDocumentMouseMove( event ) {

				if ( isUserInteracting === true ) {

					lon = ( onPointerDownPointerX - event.clientX ) * 0.1 + onPointerDownLon;
					lat = ( event.clientY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;

				}

			}

			function onDocumentMouseUp( event ) {

				isUserInteracting = false;

			}

			function onDocumentMouseWheel( event ) {

				camera.fov += event.deltaY * 0.75;
				camera.updateProjectionMatrix();

			}

			function animate() {

				requestAnimationFrame( animate );
				update();

			}

			function update() {

				if ( isUserInteracting === false ) {

					lon += 0;

				}

                if (camera) {
    				lat = Math.max( - 85, Math.min( 85, lat ) );
    				phi = THREE.Math.degToRad( 90 - lat );
    				theta = THREE.Math.degToRad( lon );
    
    				camera.target.x = 500 * Math.sin( phi ) * Math.cos( theta );
    				camera.target.y = 500 * Math.cos( phi );
    				camera.target.z = 500 * Math.sin( phi ) * Math.sin( theta );
    
    				camera.lookAt( camera.target );
    
    				/*
    				// distortion
    				camera.position.copy( camera.target ).negate();
    				*/
    
    				renderer.render( scene, camera );
                }
			}

		</script>
	</body>
</html>
